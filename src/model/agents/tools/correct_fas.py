import json
from langchain.tools import tool
import sys
from pathlib import Path
from minio import Minio
from minio.error import S3Error
from io import StringIO
from io import BytesIO

current_file = Path(__file__).resolve()
project_root = current_file.parents[4] 
# 将项目根目录添加到 sys.path
sys.path.append(str(project_root))
from config import CONFIG_YAML

# MinIO 配置:
MINIO_CONFIG = CONFIG_YAML["MINIO"]
MINIO_ENDPOINT = MINIO_CONFIG["endpoint"]
MINIO_ACCESS_KEY = MINIO_CONFIG["access_key"]
MINIO_SECRET_KEY = MINIO_CONFIG["secret_key"]
MINIO_BUCKET = MINIO_CONFIG["bucket"]
MINIO_SECURE = MINIO_CONFIG.get("secure", False)

# 初始化 MinIO 客户端
minio_client = Minio(
    MINIO_ENDPOINT,
    access_key=MINIO_ACCESS_KEY,
    secret_key=MINIO_SECRET_KEY,
    secure=MINIO_SECURE
)


# 定义有效氨基酸集合
valid_amino_acids = set('ACDEFGHIKLMNPQRSTVWYX')



def process_record(header, sequence_lines, records):
    """处理单个FASTA记录"""
    sequence = ''.join(sequence_lines).upper()
    valid_chars = [char for char in sequence if char in valid_amino_acids]
    cleaned_sequence = ''.join(valid_chars)

    # 长度检查
    if not 8 <= len(cleaned_sequence) <= 20000:
        print(f"严重错误 记录 {header}: 无效序列长度 ({len(cleaned_sequence)} aa)")
        return  # 跳过无效记录

    records.append((header, cleaned_sequence))

def format_output(records):
    """生成校正后的FASTA格式"""
    output = []
    for header, seq in records:
        output.append(header)
        # 按标准FASTA格式换行（每行70个字符）
        for i in range(0, len(seq), 70):
            output.append(seq[i:i+70])
    return '\n'.join(output)

@tool
def Correct_Fas(input_file):
    """
    Use the Correct_fas tool to correct the file generated by the validate_fas tool with an OK value of 0
    Args:
        input_file: input the path address of the file
    Return:
        The result is returned in the form of a string and a dictionary, 
        where 'ok' is 0 to indicate successful correction, and the corrected file address is in 'url' OK '=1 indicates correction failure, URL is empty.
    """
    try:
        records = []  # 用于存储解析后的FASTA记录
        current_header = None  # 当前正在处理的header
        current_sequence = []  # 当前正在处理的序列
        line_num = 0  # 当前行号
        last_was_header = False  # 上一行是否是header行
            #提取桶名和文件
        try:
            # 去掉 minio:// 前缀
            path_without_prefix = input_file[len("minio://"):]
            
            # 找到第一个斜杠的位置，用于分割 bucket_name 和 object_name
            first_slash_index = path_without_prefix.find("/")
            
            if first_slash_index == -1:
                raise ValueError("Invalid file path format: missing bucket name or object name")
            
            # 提取 bucket_name 和 object_name
            bucket_name = path_without_prefix[:first_slash_index]
            object_name = path_without_prefix[first_slash_index + 1:]
            
            # 打印提取结果（可选）
            # logger.info(f"Extracted bucket_name: {bucket_name}, object_name: {object_name}")
            
        except Exception as e:
            # logger.error(f"Failed to parse file_path: {file_path}, error: {str(e)}")
            raise str(status_code=400, detail=f"Failed to parse file path: {str(e)}")     

        try:
            response = minio_client.get_object(bucket_name, object_name)
            file_content = response.read().decode("utf-8")
            print(type(file_content))  # 应该是 <class 'str'>
            print("File content:", file_content)  # 打印文件内容以检查
        except S3Error as e:
            return json.dumps({
                "type": "error",
                "content": f"无法从 MinIO 读取文件: {str(e)}"
            }, ensure_ascii=False)    


        # 尝试打开输入文件
        try:
            file_lines = StringIO(file_content).readlines()
            for line in file_lines:
                line_num += 1
                stripped = line.strip()

                # 处理空行
                if not stripped:
                    if current_header is not None:
                        print(f"警告 行 {line_num}: 发现空行，已自动删除")
                    continue

                # 处理header行
                if stripped.startswith('>'):
                    # 前导内容检查
                    if line.startswith(' ') or line.startswith('\t'):
                        print(f"错误 行 {line_num}: Header行包含前导空格，已自动删除")

                    # 处理连续header行
                    if last_was_header:
                        print(f"错误 行 {line_num}: 发现连续的header行，已自动合并")

                    # 如果当前正在处理一个记录，先保存
                    if current_header is not None:
                        process_record(current_header, current_sequence, records)

                    # 开始新的记录
                    current_header = stripped.lstrip()  # 去掉前导空格
                    current_sequence = []
                    last_was_header = True
                    continue
                # 处理序列行
                last_was_header = False
                # 检查序列中是否包含 '>'
                if '>' in stripped:
                    # 拆分序列
                    parts = stripped.split('>')
                    # 第一部分属于当前序列
                    current_sequence.append(parts[0])
                    # 处理剩余部分
                    for part in parts[1:]:
                        # 保存当前记录
                        process_record(current_header, current_sequence, records)
                        # 开始新的记录
                        current_header = '>' + part
                        current_sequence = []
                else:
                    # 如果没有 '>'，直接添加到当前序列
                    current_sequence.append(stripped)
            # 处理最后一个记录
            if current_header is not None:
                process_record(current_header, current_sequence, records)
        except FileNotFoundError:
            result =  {
                "type": "validity",
                "ok": 1,
                "url":"",
                "msg": f"错误：文件 '{input_file}' 未找到"
            }
        except PermissionError:
            result =  {
                "type": "validity",
                "ok": 1,
                "url":"",
                "msg": f"错误：没有权限读取文件 '{input_file}'"
            }
        except UnicodeDecodeError:
            result =  {
                "type": "validity",
                "ok": 1,
                "url":"",
                "msg": f"错误：文件 '{input_file}' 编码格式不支持"
            }

        # 生成校正后的FASTA内容
        corrected_fasta = format_output(records)
        # 将校正后的文件上传回 MinIO
        try:
            corrected_bytes = corrected_fasta.encode("utf-8")
            data_stream = BytesIO(corrected_bytes)
            # 将校正后的内容上传到 MinIO
            minio_client.put_object(
                bucket_name,
                object_name,  # 覆盖原始文件
                data_stream,
                len(corrected_bytes)
            )
            result = {
                "type": "validity",
                "ok": 0,
                "url": input_file,  # 返回原始 MinIO 路径
                "msg": "已经完成校验，若有严重错误需要手动修改"
            }
        except S3Error as e:
            result = {
                "type": "validity",
                "ok": 1,
                "url": "",
                "msg": f"无法将校正后的文件上传到 MinIO: {str(e)}"
            }
    except Exception as e:
        # 捕获其他未预见的异常
        result = {
            "type": "validity",
            "ok": 1,
            "url":"",
            "msg": f"未知错误：{str(e)}"
        }
    return json.dumps(result, ensure_ascii=False)



if __name__ == "__main__":
    input_file = r"src\model\agents\tools\test.fsa"
    correction_result = Correct_Fas(input_file)

    # 输出校正结果
    print(correction_result)